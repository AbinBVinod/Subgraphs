// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt,
} from "@graphprotocol/graph-ts";

export class BuyUSDF extends ethereum.Event {
  get params(): BuyUSDF__Params {
    return new BuyUSDF__Params(this);
  }
}

export class BuyUSDF__Params {
  _event: BuyUSDF;

  constructor(event: BuyUSDF) {
    this._event = event;
  }

  get account(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get token(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get tokenAmount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get usdfAmount(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get feeBasisPoints(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }
}

export class ClosePosition extends ethereum.Event {
  get params(): ClosePosition__Params {
    return new ClosePosition__Params(this);
  }
}

export class ClosePosition__Params {
  _event: ClosePosition;

  constructor(event: ClosePosition) {
    this._event = event;
  }

  get key(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get size(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get collateral(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get averagePrice(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get entryRolloverRate(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }

  get reserveAmount(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }

  get realisedPnl(): BigInt {
    return this._event.parameters[6].value.toBigInt();
  }
}

export class CollectPositionTradeFees extends ethereum.Event {
  get params(): CollectPositionTradeFees__Params {
    return new CollectPositionTradeFees__Params(this);
  }
}

export class CollectPositionTradeFees__Params {
  _event: CollectPositionTradeFees;

  constructor(event: CollectPositionTradeFees) {
    this._event = event;
  }

  get token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get feeUsd(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get feeTokens(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class CollectSwapFees extends ethereum.Event {
  get params(): CollectSwapFees__Params {
    return new CollectSwapFees__Params(this);
  }
}

export class CollectSwapFees__Params {
  _event: CollectSwapFees;

  constructor(event: CollectSwapFees) {
    this._event = event;
  }

  get token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get feeUsd(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get feeTokens(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class DecreaseGuaranteedUsd extends ethereum.Event {
  get params(): DecreaseGuaranteedUsd__Params {
    return new DecreaseGuaranteedUsd__Params(this);
  }
}

export class DecreaseGuaranteedUsd__Params {
  _event: DecreaseGuaranteedUsd;

  constructor(event: DecreaseGuaranteedUsd) {
    this._event = event;
  }

  get token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class DecreasePoolAmount extends ethereum.Event {
  get params(): DecreasePoolAmount__Params {
    return new DecreasePoolAmount__Params(this);
  }
}

export class DecreasePoolAmount__Params {
  _event: DecreasePoolAmount;

  constructor(event: DecreasePoolAmount) {
    this._event = event;
  }

  get token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class DecreasePosition extends ethereum.Event {
  get params(): DecreasePosition__Params {
    return new DecreasePosition__Params(this);
  }
}

export class DecreasePosition__Params {
  _event: DecreasePosition;

  constructor(event: DecreasePosition) {
    this._event = event;
  }

  get key(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get account(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get collateralToken(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get indexToken(): Address {
    return this._event.parameters[3].value.toAddress();
  }

  get collateralDelta(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }

  get sizeDelta(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }

  get isLong(): boolean {
    return this._event.parameters[6].value.toBoolean();
  }

  get price(): BigInt {
    return this._event.parameters[7].value.toBigInt();
  }

  get fee(): BigInt {
    return this._event.parameters[8].value.toBigInt();
  }
}

export class DecreaseReservedAmount extends ethereum.Event {
  get params(): DecreaseReservedAmount__Params {
    return new DecreaseReservedAmount__Params(this);
  }
}

export class DecreaseReservedAmount__Params {
  _event: DecreaseReservedAmount;

  constructor(event: DecreaseReservedAmount) {
    this._event = event;
  }

  get token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class DecreaseUsdfAmount extends ethereum.Event {
  get params(): DecreaseUsdfAmount__Params {
    return new DecreaseUsdfAmount__Params(this);
  }
}

export class DecreaseUsdfAmount__Params {
  _event: DecreaseUsdfAmount;

  constructor(event: DecreaseUsdfAmount) {
    this._event = event;
  }

  get token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class DirectPoolDeposit extends ethereum.Event {
  get params(): DirectPoolDeposit__Params {
    return new DirectPoolDeposit__Params(this);
  }
}

export class DirectPoolDeposit__Params {
  _event: DirectPoolDeposit;

  constructor(event: DirectPoolDeposit) {
    this._event = event;
  }

  get token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class IncreaseGuaranteedUsd extends ethereum.Event {
  get params(): IncreaseGuaranteedUsd__Params {
    return new IncreaseGuaranteedUsd__Params(this);
  }
}

export class IncreaseGuaranteedUsd__Params {
  _event: IncreaseGuaranteedUsd;

  constructor(event: IncreaseGuaranteedUsd) {
    this._event = event;
  }

  get token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class IncreasePoolAmount extends ethereum.Event {
  get params(): IncreasePoolAmount__Params {
    return new IncreasePoolAmount__Params(this);
  }
}

export class IncreasePoolAmount__Params {
  _event: IncreasePoolAmount;

  constructor(event: IncreasePoolAmount) {
    this._event = event;
  }

  get token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class IncreasePosition extends ethereum.Event {
  get params(): IncreasePosition__Params {
    return new IncreasePosition__Params(this);
  }
}

export class IncreasePosition__Params {
  _event: IncreasePosition;

  constructor(event: IncreasePosition) {
    this._event = event;
  }

  get key(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get account(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get collateralToken(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get indexToken(): Address {
    return this._event.parameters[3].value.toAddress();
  }

  get collateralDelta(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }

  get sizeDelta(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }

  get isLong(): boolean {
    return this._event.parameters[6].value.toBoolean();
  }

  get price(): BigInt {
    return this._event.parameters[7].value.toBigInt();
  }

  get fee(): BigInt {
    return this._event.parameters[8].value.toBigInt();
  }
}

export class IncreaseReservedAmount extends ethereum.Event {
  get params(): IncreaseReservedAmount__Params {
    return new IncreaseReservedAmount__Params(this);
  }
}

export class IncreaseReservedAmount__Params {
  _event: IncreaseReservedAmount;

  constructor(event: IncreaseReservedAmount) {
    this._event = event;
  }

  get token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class IncreaseUsdfAmount extends ethereum.Event {
  get params(): IncreaseUsdfAmount__Params {
    return new IncreaseUsdfAmount__Params(this);
  }
}

export class IncreaseUsdfAmount__Params {
  _event: IncreaseUsdfAmount;

  constructor(event: IncreaseUsdfAmount) {
    this._event = event;
  }

  get token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class LiquidatePosition extends ethereum.Event {
  get params(): LiquidatePosition__Params {
    return new LiquidatePosition__Params(this);
  }
}

export class LiquidatePosition__Params {
  _event: LiquidatePosition;

  constructor(event: LiquidatePosition) {
    this._event = event;
  }

  get key(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get account(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get collateralToken(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get indexToken(): Address {
    return this._event.parameters[3].value.toAddress();
  }

  get isLong(): boolean {
    return this._event.parameters[4].value.toBoolean();
  }

  get size(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }

  get collateral(): BigInt {
    return this._event.parameters[6].value.toBigInt();
  }

  get reserveAmount(): BigInt {
    return this._event.parameters[7].value.toBigInt();
  }

  get realisedPnl(): BigInt {
    return this._event.parameters[8].value.toBigInt();
  }

  get markPrice(): BigInt {
    return this._event.parameters[9].value.toBigInt();
  }
}

export class SellUSDF extends ethereum.Event {
  get params(): SellUSDF__Params {
    return new SellUSDF__Params(this);
  }
}

export class SellUSDF__Params {
  _event: SellUSDF;

  constructor(event: SellUSDF) {
    this._event = event;
  }

  get account(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get token(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get usdfAmount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get tokenAmount(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get feeBasisPoints(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }
}

export class Swap extends ethereum.Event {
  get params(): Swap__Params {
    return new Swap__Params(this);
  }
}

export class Swap__Params {
  _event: Swap;

  constructor(event: Swap) {
    this._event = event;
  }

  get account(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get tokenIn(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get tokenOut(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get amountIn(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get amountOut(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }

  get amountOutAfterFees(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }

  get feeBasisPoints(): BigInt {
    return this._event.parameters[6].value.toBigInt();
  }
}

export class UpdatePnl extends ethereum.Event {
  get params(): UpdatePnl__Params {
    return new UpdatePnl__Params(this);
  }
}

export class UpdatePnl__Params {
  _event: UpdatePnl;

  constructor(event: UpdatePnl) {
    this._event = event;
  }

  get key(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get hasProfit(): boolean {
    return this._event.parameters[1].value.toBoolean();
  }

  get delta(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class UpdatePosition extends ethereum.Event {
  get params(): UpdatePosition__Params {
    return new UpdatePosition__Params(this);
  }
}

export class UpdatePosition__Params {
  _event: UpdatePosition;

  constructor(event: UpdatePosition) {
    this._event = event;
  }

  get key(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get size(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get collateral(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get averagePrice(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get entryRolloverRate(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }

  get reserveAmount(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }

  get realisedPnl(): BigInt {
    return this._event.parameters[6].value.toBigInt();
  }

  get markPrice(): BigInt {
    return this._event.parameters[7].value.toBigInt();
  }
}

export class Vault__getDeltaResult {
  value0: boolean;
  value1: BigInt;

  constructor(value0: boolean, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromBoolean(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getValue0(): boolean {
    return this.value0;
  }

  getValue1(): BigInt {
    return this.value1;
  }
}

export class Vault__getGlobalShortDeltaResult {
  value0: boolean;
  value1: BigInt;

  constructor(value0: boolean, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromBoolean(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getValue0(): boolean {
    return this.value0;
  }

  getValue1(): BigInt {
    return this.value1;
  }
}

export class Vault__getPositionResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;
  value3: BigInt;
  value4: BigInt;
  value5: BigInt;
  value6: boolean;
  value7: BigInt;

  constructor(
    value0: BigInt,
    value1: BigInt,
    value2: BigInt,
    value3: BigInt,
    value4: BigInt,
    value5: BigInt,
    value6: boolean,
    value7: BigInt,
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
    this.value4 = value4;
    this.value5 = value5;
    this.value6 = value6;
    this.value7 = value7;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    map.set("value3", ethereum.Value.fromUnsignedBigInt(this.value3));
    map.set("value4", ethereum.Value.fromUnsignedBigInt(this.value4));
    map.set("value5", ethereum.Value.fromUnsignedBigInt(this.value5));
    map.set("value6", ethereum.Value.fromBoolean(this.value6));
    map.set("value7", ethereum.Value.fromUnsignedBigInt(this.value7));
    return map;
  }

  getValue0(): BigInt {
    return this.value0;
  }

  getValue1(): BigInt {
    return this.value1;
  }

  getValue2(): BigInt {
    return this.value2;
  }

  getValue3(): BigInt {
    return this.value3;
  }

  getValue4(): BigInt {
    return this.value4;
  }

  getValue5(): BigInt {
    return this.value5;
  }

  getValue6(): boolean {
    return this.value6;
  }

  getValue7(): BigInt {
    return this.value7;
  }
}

export class Vault__getPositionDeltaResult {
  value0: boolean;
  value1: BigInt;

  constructor(value0: boolean, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromBoolean(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getValue0(): boolean {
    return this.value0;
  }

  getValue1(): BigInt {
    return this.value1;
  }
}

export class Vault__positionsResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;
  value3: BigInt;
  value4: BigInt;
  value5: BigInt;
  value6: BigInt;

  constructor(
    value0: BigInt,
    value1: BigInt,
    value2: BigInt,
    value3: BigInt,
    value4: BigInt,
    value5: BigInt,
    value6: BigInt,
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
    this.value4 = value4;
    this.value5 = value5;
    this.value6 = value6;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    map.set("value3", ethereum.Value.fromUnsignedBigInt(this.value3));
    map.set("value4", ethereum.Value.fromUnsignedBigInt(this.value4));
    map.set("value5", ethereum.Value.fromSignedBigInt(this.value5));
    map.set("value6", ethereum.Value.fromUnsignedBigInt(this.value6));
    return map;
  }

  getSize(): BigInt {
    return this.value0;
  }

  getCollateral(): BigInt {
    return this.value1;
  }

  getAveragePrice(): BigInt {
    return this.value2;
  }

  getEntryRolloverRate(): BigInt {
    return this.value3;
  }

  getReserveAmount(): BigInt {
    return this.value4;
  }

  getRealisedPnl(): BigInt {
    return this.value5;
  }

  getLastIncreasedTime(): BigInt {
    return this.value6;
  }
}

export class Vault__validateLiquidationResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getValue0(): BigInt {
    return this.value0;
  }

  getValue1(): BigInt {
    return this.value1;
  }
}

export class Vault extends ethereum.SmartContract {
  static bind(address: Address): Vault {
    return new Vault("Vault", address);
  }

  BASIS_POINTS_DIVISOR(): BigInt {
    let result = super.call(
      "BASIS_POINTS_DIVISOR",
      "BASIS_POINTS_DIVISOR():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_BASIS_POINTS_DIVISOR(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "BASIS_POINTS_DIVISOR",
      "BASIS_POINTS_DIVISOR():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  FUNDING_RATE_PRECISION(): BigInt {
    let result = super.call(
      "FUNDING_RATE_PRECISION",
      "FUNDING_RATE_PRECISION():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_FUNDING_RATE_PRECISION(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "FUNDING_RATE_PRECISION",
      "FUNDING_RATE_PRECISION():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  MIN_LEVERAGE(): BigInt {
    let result = super.call("MIN_LEVERAGE", "MIN_LEVERAGE():(uint256)", []);

    return result[0].toBigInt();
  }

  try_MIN_LEVERAGE(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("MIN_LEVERAGE", "MIN_LEVERAGE():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  PRICE_PRECISION(): BigInt {
    let result = super.call(
      "PRICE_PRECISION",
      "PRICE_PRECISION():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_PRICE_PRECISION(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "PRICE_PRECISION",
      "PRICE_PRECISION():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  USDF_DECIMALS(): BigInt {
    let result = super.call("USDF_DECIMALS", "USDF_DECIMALS():(uint256)", []);

    return result[0].toBigInt();
  }

  try_USDF_DECIMALS(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "USDF_DECIMALS",
      "USDF_DECIMALS():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  adjustForDecimals(
    _amount: BigInt,
    _tokenDiv: Address,
    _tokenMul: Address,
  ): BigInt {
    let result = super.call(
      "adjustForDecimals",
      "adjustForDecimals(uint256,address,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(_amount),
        ethereum.Value.fromAddress(_tokenDiv),
        ethereum.Value.fromAddress(_tokenMul),
      ],
    );

    return result[0].toBigInt();
  }

  try_adjustForDecimals(
    _amount: BigInt,
    _tokenDiv: Address,
    _tokenMul: Address,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "adjustForDecimals",
      "adjustForDecimals(uint256,address,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(_amount),
        ethereum.Value.fromAddress(_tokenDiv),
        ethereum.Value.fromAddress(_tokenMul),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  allWhitelistedTokens(param0: BigInt): Address {
    let result = super.call(
      "allWhitelistedTokens",
      "allWhitelistedTokens(uint256):(address)",
      [ethereum.Value.fromUnsignedBigInt(param0)],
    );

    return result[0].toAddress();
  }

  try_allWhitelistedTokens(param0: BigInt): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "allWhitelistedTokens",
      "allWhitelistedTokens(uint256):(address)",
      [ethereum.Value.fromUnsignedBigInt(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  allWhitelistedTokensLength(): BigInt {
    let result = super.call(
      "allWhitelistedTokensLength",
      "allWhitelistedTokensLength():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_allWhitelistedTokensLength(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "allWhitelistedTokensLength",
      "allWhitelistedTokensLength():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  approvedRouters(param0: Address, param1: Address): boolean {
    let result = super.call(
      "approvedRouters",
      "approvedRouters(address,address):(bool)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)],
    );

    return result[0].toBoolean();
  }

  try_approvedRouters(
    param0: Address,
    param1: Address,
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "approvedRouters",
      "approvedRouters(address,address):(bool)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  bufferAmounts(param0: Address): BigInt {
    let result = super.call(
      "bufferAmounts",
      "bufferAmounts(address):(uint256)",
      [ethereum.Value.fromAddress(param0)],
    );

    return result[0].toBigInt();
  }

  try_bufferAmounts(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "bufferAmounts",
      "bufferAmounts(address):(uint256)",
      [ethereum.Value.fromAddress(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  buyUSDF(_token: Address, _receiver: Address): BigInt {
    let result = super.call("buyUSDF", "buyUSDF(address,address):(uint256)", [
      ethereum.Value.fromAddress(_token),
      ethereum.Value.fromAddress(_receiver),
    ]);

    return result[0].toBigInt();
  }

  try_buyUSDF(
    _token: Address,
    _receiver: Address,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "buyUSDF",
      "buyUSDF(address,address):(uint256)",
      [
        ethereum.Value.fromAddress(_token),
        ethereum.Value.fromAddress(_receiver),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  decreasePosition(
    _account: Address,
    _collateralToken: Address,
    _indexToken: Address,
    _collateralDelta: BigInt,
    _sizeDelta: BigInt,
    _isLong: boolean,
    _receiver: Address,
  ): BigInt {
    let result = super.call(
      "decreasePosition",
      "decreasePosition(address,address,address,uint256,uint256,bool,address):(uint256)",
      [
        ethereum.Value.fromAddress(_account),
        ethereum.Value.fromAddress(_collateralToken),
        ethereum.Value.fromAddress(_indexToken),
        ethereum.Value.fromUnsignedBigInt(_collateralDelta),
        ethereum.Value.fromUnsignedBigInt(_sizeDelta),
        ethereum.Value.fromBoolean(_isLong),
        ethereum.Value.fromAddress(_receiver),
      ],
    );

    return result[0].toBigInt();
  }

  try_decreasePosition(
    _account: Address,
    _collateralToken: Address,
    _indexToken: Address,
    _collateralDelta: BigInt,
    _sizeDelta: BigInt,
    _isLong: boolean,
    _receiver: Address,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "decreasePosition",
      "decreasePosition(address,address,address,uint256,uint256,bool,address):(uint256)",
      [
        ethereum.Value.fromAddress(_account),
        ethereum.Value.fromAddress(_collateralToken),
        ethereum.Value.fromAddress(_indexToken),
        ethereum.Value.fromUnsignedBigInt(_collateralDelta),
        ethereum.Value.fromUnsignedBigInt(_sizeDelta),
        ethereum.Value.fromBoolean(_isLong),
        ethereum.Value.fromAddress(_receiver),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  errorController(): Address {
    let result = super.call(
      "errorController",
      "errorController():(address)",
      [],
    );

    return result[0].toAddress();
  }

  try_errorController(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "errorController",
      "errorController():(address)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  errors(param0: BigInt): string {
    let result = super.call("errors", "errors(uint256):(string)", [
      ethereum.Value.fromUnsignedBigInt(param0),
    ]);

    return result[0].toString();
  }

  try_errors(param0: BigInt): ethereum.CallResult<string> {
    let result = super.tryCall("errors", "errors(uint256):(string)", [
      ethereum.Value.fromUnsignedBigInt(param0),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  feeReserves(param0: Address): BigInt {
    let result = super.call("feeReserves", "feeReserves(address):(uint256)", [
      ethereum.Value.fromAddress(param0),
    ]);

    return result[0].toBigInt();
  }

  try_feeReserves(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "feeReserves",
      "feeReserves(address):(uint256)",
      [ethereum.Value.fromAddress(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  feeUtils(): Address {
    let result = super.call("feeUtils", "feeUtils():(address)", []);

    return result[0].toAddress();
  }

  try_feeUtils(): ethereum.CallResult<Address> {
    let result = super.tryCall("feeUtils", "feeUtils():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getDelta(
    _indexToken: Address,
    _size: BigInt,
    _averagePrice: BigInt,
    _isLong: boolean,
    _lastIncreasedTime: BigInt,
  ): Vault__getDeltaResult {
    let result = super.call(
      "getDelta",
      "getDelta(address,uint256,uint256,bool,uint256):(bool,uint256)",
      [
        ethereum.Value.fromAddress(_indexToken),
        ethereum.Value.fromUnsignedBigInt(_size),
        ethereum.Value.fromUnsignedBigInt(_averagePrice),
        ethereum.Value.fromBoolean(_isLong),
        ethereum.Value.fromUnsignedBigInt(_lastIncreasedTime),
      ],
    );

    return new Vault__getDeltaResult(
      result[0].toBoolean(),
      result[1].toBigInt(),
    );
  }

  try_getDelta(
    _indexToken: Address,
    _size: BigInt,
    _averagePrice: BigInt,
    _isLong: boolean,
    _lastIncreasedTime: BigInt,
  ): ethereum.CallResult<Vault__getDeltaResult> {
    let result = super.tryCall(
      "getDelta",
      "getDelta(address,uint256,uint256,bool,uint256):(bool,uint256)",
      [
        ethereum.Value.fromAddress(_indexToken),
        ethereum.Value.fromUnsignedBigInt(_size),
        ethereum.Value.fromUnsignedBigInt(_averagePrice),
        ethereum.Value.fromBoolean(_isLong),
        ethereum.Value.fromUnsignedBigInt(_lastIncreasedTime),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Vault__getDeltaResult(value[0].toBoolean(), value[1].toBigInt()),
    );
  }

  getFeeUtils(): Address {
    let result = super.call("getFeeUtils", "getFeeUtils():(address)", []);

    return result[0].toAddress();
  }

  try_getFeeUtils(): ethereum.CallResult<Address> {
    let result = super.tryCall("getFeeUtils", "getFeeUtils():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getGlobalShortDelta(_token: Address): Vault__getGlobalShortDeltaResult {
    let result = super.call(
      "getGlobalShortDelta",
      "getGlobalShortDelta(address):(bool,uint256)",
      [ethereum.Value.fromAddress(_token)],
    );

    return new Vault__getGlobalShortDeltaResult(
      result[0].toBoolean(),
      result[1].toBigInt(),
    );
  }

  try_getGlobalShortDelta(
    _token: Address,
  ): ethereum.CallResult<Vault__getGlobalShortDeltaResult> {
    let result = super.tryCall(
      "getGlobalShortDelta",
      "getGlobalShortDelta(address):(bool,uint256)",
      [ethereum.Value.fromAddress(_token)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Vault__getGlobalShortDeltaResult(
        value[0].toBoolean(),
        value[1].toBigInt(),
      ),
    );
  }

  getMaxPrice(_token: Address): BigInt {
    let result = super.call("getMaxPrice", "getMaxPrice(address):(uint256)", [
      ethereum.Value.fromAddress(_token),
    ]);

    return result[0].toBigInt();
  }

  try_getMaxPrice(_token: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getMaxPrice",
      "getMaxPrice(address):(uint256)",
      [ethereum.Value.fromAddress(_token)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getMinPrice(_token: Address): BigInt {
    let result = super.call("getMinPrice", "getMinPrice(address):(uint256)", [
      ethereum.Value.fromAddress(_token),
    ]);

    return result[0].toBigInt();
  }

  try_getMinPrice(_token: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getMinPrice",
      "getMinPrice(address):(uint256)",
      [ethereum.Value.fromAddress(_token)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getNextAveragePrice(
    _indexToken: Address,
    _size: BigInt,
    _averagePrice: BigInt,
    _isLong: boolean,
    _nextPrice: BigInt,
    _sizeDelta: BigInt,
    _lastIncreasedTime: BigInt,
  ): BigInt {
    let result = super.call(
      "getNextAveragePrice",
      "getNextAveragePrice(address,uint256,uint256,bool,uint256,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(_indexToken),
        ethereum.Value.fromUnsignedBigInt(_size),
        ethereum.Value.fromUnsignedBigInt(_averagePrice),
        ethereum.Value.fromBoolean(_isLong),
        ethereum.Value.fromUnsignedBigInt(_nextPrice),
        ethereum.Value.fromUnsignedBigInt(_sizeDelta),
        ethereum.Value.fromUnsignedBigInt(_lastIncreasedTime),
      ],
    );

    return result[0].toBigInt();
  }

  try_getNextAveragePrice(
    _indexToken: Address,
    _size: BigInt,
    _averagePrice: BigInt,
    _isLong: boolean,
    _nextPrice: BigInt,
    _sizeDelta: BigInt,
    _lastIncreasedTime: BigInt,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getNextAveragePrice",
      "getNextAveragePrice(address,uint256,uint256,bool,uint256,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(_indexToken),
        ethereum.Value.fromUnsignedBigInt(_size),
        ethereum.Value.fromUnsignedBigInt(_averagePrice),
        ethereum.Value.fromBoolean(_isLong),
        ethereum.Value.fromUnsignedBigInt(_nextPrice),
        ethereum.Value.fromUnsignedBigInt(_sizeDelta),
        ethereum.Value.fromUnsignedBigInt(_lastIncreasedTime),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getNextGlobalShortAveragePrice(
    _indexToken: Address,
    _nextPrice: BigInt,
    _sizeDelta: BigInt,
  ): BigInt {
    let result = super.call(
      "getNextGlobalShortAveragePrice",
      "getNextGlobalShortAveragePrice(address,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(_indexToken),
        ethereum.Value.fromUnsignedBigInt(_nextPrice),
        ethereum.Value.fromUnsignedBigInt(_sizeDelta),
      ],
    );

    return result[0].toBigInt();
  }

  try_getNextGlobalShortAveragePrice(
    _indexToken: Address,
    _nextPrice: BigInt,
    _sizeDelta: BigInt,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getNextGlobalShortAveragePrice",
      "getNextGlobalShortAveragePrice(address,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(_indexToken),
        ethereum.Value.fromUnsignedBigInt(_nextPrice),
        ethereum.Value.fromUnsignedBigInt(_sizeDelta),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getPosition(
    _account: Address,
    _collateralToken: Address,
    _indexToken: Address,
    _isLong: boolean,
  ): Vault__getPositionResult {
    let result = super.call(
      "getPosition",
      "getPosition(address,address,address,bool):(uint256,uint256,uint256,uint256,uint256,uint256,bool,uint256)",
      [
        ethereum.Value.fromAddress(_account),
        ethereum.Value.fromAddress(_collateralToken),
        ethereum.Value.fromAddress(_indexToken),
        ethereum.Value.fromBoolean(_isLong),
      ],
    );

    return new Vault__getPositionResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt(),
      result[3].toBigInt(),
      result[4].toBigInt(),
      result[5].toBigInt(),
      result[6].toBoolean(),
      result[7].toBigInt(),
    );
  }

  try_getPosition(
    _account: Address,
    _collateralToken: Address,
    _indexToken: Address,
    _isLong: boolean,
  ): ethereum.CallResult<Vault__getPositionResult> {
    let result = super.tryCall(
      "getPosition",
      "getPosition(address,address,address,bool):(uint256,uint256,uint256,uint256,uint256,uint256,bool,uint256)",
      [
        ethereum.Value.fromAddress(_account),
        ethereum.Value.fromAddress(_collateralToken),
        ethereum.Value.fromAddress(_indexToken),
        ethereum.Value.fromBoolean(_isLong),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Vault__getPositionResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt(),
        value[3].toBigInt(),
        value[4].toBigInt(),
        value[5].toBigInt(),
        value[6].toBoolean(),
        value[7].toBigInt(),
      ),
    );
  }

  getPositionDelta(
    _account: Address,
    _collateralToken: Address,
    _indexToken: Address,
    _isLong: boolean,
  ): Vault__getPositionDeltaResult {
    let result = super.call(
      "getPositionDelta",
      "getPositionDelta(address,address,address,bool):(bool,uint256)",
      [
        ethereum.Value.fromAddress(_account),
        ethereum.Value.fromAddress(_collateralToken),
        ethereum.Value.fromAddress(_indexToken),
        ethereum.Value.fromBoolean(_isLong),
      ],
    );

    return new Vault__getPositionDeltaResult(
      result[0].toBoolean(),
      result[1].toBigInt(),
    );
  }

  try_getPositionDelta(
    _account: Address,
    _collateralToken: Address,
    _indexToken: Address,
    _isLong: boolean,
  ): ethereum.CallResult<Vault__getPositionDeltaResult> {
    let result = super.tryCall(
      "getPositionDelta",
      "getPositionDelta(address,address,address,bool):(bool,uint256)",
      [
        ethereum.Value.fromAddress(_account),
        ethereum.Value.fromAddress(_collateralToken),
        ethereum.Value.fromAddress(_indexToken),
        ethereum.Value.fromBoolean(_isLong),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Vault__getPositionDeltaResult(
        value[0].toBoolean(),
        value[1].toBigInt(),
      ),
    );
  }

  getPositionKey(
    _account: Address,
    _collateralToken: Address,
    _indexToken: Address,
    _isLong: boolean,
  ): Bytes {
    let result = super.call(
      "getPositionKey",
      "getPositionKey(address,address,address,bool):(bytes32)",
      [
        ethereum.Value.fromAddress(_account),
        ethereum.Value.fromAddress(_collateralToken),
        ethereum.Value.fromAddress(_indexToken),
        ethereum.Value.fromBoolean(_isLong),
      ],
    );

    return result[0].toBytes();
  }

  try_getPositionKey(
    _account: Address,
    _collateralToken: Address,
    _indexToken: Address,
    _isLong: boolean,
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "getPositionKey",
      "getPositionKey(address,address,address,bool):(bytes32)",
      [
        ethereum.Value.fromAddress(_account),
        ethereum.Value.fromAddress(_collateralToken),
        ethereum.Value.fromAddress(_indexToken),
        ethereum.Value.fromBoolean(_isLong),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  getPositionLeverage(
    _account: Address,
    _collateralToken: Address,
    _indexToken: Address,
    _isLong: boolean,
  ): BigInt {
    let result = super.call(
      "getPositionLeverage",
      "getPositionLeverage(address,address,address,bool):(uint256)",
      [
        ethereum.Value.fromAddress(_account),
        ethereum.Value.fromAddress(_collateralToken),
        ethereum.Value.fromAddress(_indexToken),
        ethereum.Value.fromBoolean(_isLong),
      ],
    );

    return result[0].toBigInt();
  }

  try_getPositionLeverage(
    _account: Address,
    _collateralToken: Address,
    _indexToken: Address,
    _isLong: boolean,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getPositionLeverage",
      "getPositionLeverage(address,address,address,bool):(uint256)",
      [
        ethereum.Value.fromAddress(_account),
        ethereum.Value.fromAddress(_collateralToken),
        ethereum.Value.fromAddress(_indexToken),
        ethereum.Value.fromBoolean(_isLong),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getRedemptionAmount(_token: Address, _usdfAmount: BigInt): BigInt {
    let result = super.call(
      "getRedemptionAmount",
      "getRedemptionAmount(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(_token),
        ethereum.Value.fromUnsignedBigInt(_usdfAmount),
      ],
    );

    return result[0].toBigInt();
  }

  try_getRedemptionAmount(
    _token: Address,
    _usdfAmount: BigInt,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getRedemptionAmount",
      "getRedemptionAmount(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(_token),
        ethereum.Value.fromUnsignedBigInt(_usdfAmount),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getRedemptionCollateral(_token: Address): BigInt {
    let result = super.call(
      "getRedemptionCollateral",
      "getRedemptionCollateral(address):(uint256)",
      [ethereum.Value.fromAddress(_token)],
    );

    return result[0].toBigInt();
  }

  try_getRedemptionCollateral(_token: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getRedemptionCollateral",
      "getRedemptionCollateral(address):(uint256)",
      [ethereum.Value.fromAddress(_token)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getRedemptionCollateralUsd(_token: Address): BigInt {
    let result = super.call(
      "getRedemptionCollateralUsd",
      "getRedemptionCollateralUsd(address):(uint256)",
      [ethereum.Value.fromAddress(_token)],
    );

    return result[0].toBigInt();
  }

  try_getRedemptionCollateralUsd(_token: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getRedemptionCollateralUsd",
      "getRedemptionCollateralUsd(address):(uint256)",
      [ethereum.Value.fromAddress(_token)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getTargetUsdfAmount(_token: Address): BigInt {
    let result = super.call(
      "getTargetUsdfAmount",
      "getTargetUsdfAmount(address):(uint256)",
      [ethereum.Value.fromAddress(_token)],
    );

    return result[0].toBigInt();
  }

  try_getTargetUsdfAmount(_token: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getTargetUsdfAmount",
      "getTargetUsdfAmount(address):(uint256)",
      [ethereum.Value.fromAddress(_token)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getUtilisation(_token: Address): BigInt {
    let result = super.call(
      "getUtilisation",
      "getUtilisation(address):(uint256)",
      [ethereum.Value.fromAddress(_token)],
    );

    return result[0].toBigInt();
  }

  try_getUtilisation(_token: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getUtilisation",
      "getUtilisation(address):(uint256)",
      [ethereum.Value.fromAddress(_token)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getVaultUtils(): Address {
    let result = super.call("getVaultUtils", "getVaultUtils():(address)", []);

    return result[0].toAddress();
  }

  try_getVaultUtils(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getVaultUtils",
      "getVaultUtils():(address)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  globalShortAveragePrices(param0: Address): BigInt {
    let result = super.call(
      "globalShortAveragePrices",
      "globalShortAveragePrices(address):(uint256)",
      [ethereum.Value.fromAddress(param0)],
    );

    return result[0].toBigInt();
  }

  try_globalShortAveragePrices(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "globalShortAveragePrices",
      "globalShortAveragePrices(address):(uint256)",
      [ethereum.Value.fromAddress(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  globalShortSizes(param0: Address): BigInt {
    let result = super.call(
      "globalShortSizes",
      "globalShortSizes(address):(uint256)",
      [ethereum.Value.fromAddress(param0)],
    );

    return result[0].toBigInt();
  }

  try_globalShortSizes(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "globalShortSizes",
      "globalShortSizes(address):(uint256)",
      [ethereum.Value.fromAddress(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  gov(): Address {
    let result = super.call("gov", "gov():(address)", []);

    return result[0].toAddress();
  }

  try_gov(): ethereum.CallResult<Address> {
    let result = super.tryCall("gov", "gov():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  guaranteedUsd(param0: Address): BigInt {
    let result = super.call(
      "guaranteedUsd",
      "guaranteedUsd(address):(uint256)",
      [ethereum.Value.fromAddress(param0)],
    );

    return result[0].toBigInt();
  }

  try_guaranteedUsd(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "guaranteedUsd",
      "guaranteedUsd(address):(uint256)",
      [ethereum.Value.fromAddress(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  inManagerMode(): boolean {
    let result = super.call("inManagerMode", "inManagerMode():(bool)", []);

    return result[0].toBoolean();
  }

  try_inManagerMode(): ethereum.CallResult<boolean> {
    let result = super.tryCall("inManagerMode", "inManagerMode():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  inPrivateLiquidationMode(): boolean {
    let result = super.call(
      "inPrivateLiquidationMode",
      "inPrivateLiquidationMode():(bool)",
      [],
    );

    return result[0].toBoolean();
  }

  try_inPrivateLiquidationMode(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "inPrivateLiquidationMode",
      "inPrivateLiquidationMode():(bool)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  includeAmmPrice(): boolean {
    let result = super.call("includeAmmPrice", "includeAmmPrice():(bool)", []);

    return result[0].toBoolean();
  }

  try_includeAmmPrice(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "includeAmmPrice",
      "includeAmmPrice():(bool)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isInitialized(): boolean {
    let result = super.call("isInitialized", "isInitialized():(bool)", []);

    return result[0].toBoolean();
  }

  try_isInitialized(): ethereum.CallResult<boolean> {
    let result = super.tryCall("isInitialized", "isInitialized():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isLeverageEnabled(): boolean {
    let result = super.call(
      "isLeverageEnabled",
      "isLeverageEnabled():(bool)",
      [],
    );

    return result[0].toBoolean();
  }

  try_isLeverageEnabled(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isLeverageEnabled",
      "isLeverageEnabled():(bool)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isLiquidator(param0: Address): boolean {
    let result = super.call("isLiquidator", "isLiquidator(address):(bool)", [
      ethereum.Value.fromAddress(param0),
    ]);

    return result[0].toBoolean();
  }

  try_isLiquidator(param0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isLiquidator", "isLiquidator(address):(bool)", [
      ethereum.Value.fromAddress(param0),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isManager(param0: Address): boolean {
    let result = super.call("isManager", "isManager(address):(bool)", [
      ethereum.Value.fromAddress(param0),
    ]);

    return result[0].toBoolean();
  }

  try_isManager(param0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isManager", "isManager(address):(bool)", [
      ethereum.Value.fromAddress(param0),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isSwapEnabled(): boolean {
    let result = super.call("isSwapEnabled", "isSwapEnabled():(bool)", []);

    return result[0].toBoolean();
  }

  try_isSwapEnabled(): ethereum.CallResult<boolean> {
    let result = super.tryCall("isSwapEnabled", "isSwapEnabled():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  maxGasPrice(): BigInt {
    let result = super.call("maxGasPrice", "maxGasPrice():(uint256)", []);

    return result[0].toBigInt();
  }

  try_maxGasPrice(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("maxGasPrice", "maxGasPrice():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  maxGlobalShortSizes(param0: Address): BigInt {
    let result = super.call(
      "maxGlobalShortSizes",
      "maxGlobalShortSizes(address):(uint256)",
      [ethereum.Value.fromAddress(param0)],
    );

    return result[0].toBigInt();
  }

  try_maxGlobalShortSizes(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "maxGlobalShortSizes",
      "maxGlobalShortSizes(address):(uint256)",
      [ethereum.Value.fromAddress(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  maxLeverage(): BigInt {
    let result = super.call("maxLeverage", "maxLeverage():(uint256)", []);

    return result[0].toBigInt();
  }

  try_maxLeverage(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("maxLeverage", "maxLeverage():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  maxUsdfAmounts(param0: Address): BigInt {
    let result = super.call(
      "maxUsdfAmounts",
      "maxUsdfAmounts(address):(uint256)",
      [ethereum.Value.fromAddress(param0)],
    );

    return result[0].toBigInt();
  }

  try_maxUsdfAmounts(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "maxUsdfAmounts",
      "maxUsdfAmounts(address):(uint256)",
      [ethereum.Value.fromAddress(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  minProfitBasisPoints(param0: Address): BigInt {
    let result = super.call(
      "minProfitBasisPoints",
      "minProfitBasisPoints(address):(uint256)",
      [ethereum.Value.fromAddress(param0)],
    );

    return result[0].toBigInt();
  }

  try_minProfitBasisPoints(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "minProfitBasisPoints",
      "minProfitBasisPoints(address):(uint256)",
      [ethereum.Value.fromAddress(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  minProfitTime(): BigInt {
    let result = super.call("minProfitTime", "minProfitTime():(uint256)", []);

    return result[0].toBigInt();
  }

  try_minProfitTime(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "minProfitTime",
      "minProfitTime():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  poolAmounts(param0: Address): BigInt {
    let result = super.call("poolAmounts", "poolAmounts(address):(uint256)", [
      ethereum.Value.fromAddress(param0),
    ]);

    return result[0].toBigInt();
  }

  try_poolAmounts(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "poolAmounts",
      "poolAmounts(address):(uint256)",
      [ethereum.Value.fromAddress(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  positions(param0: Bytes): Vault__positionsResult {
    let result = super.call(
      "positions",
      "positions(bytes32):(uint256,uint256,uint256,uint256,uint256,int256,uint256)",
      [ethereum.Value.fromFixedBytes(param0)],
    );

    return new Vault__positionsResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt(),
      result[3].toBigInt(),
      result[4].toBigInt(),
      result[5].toBigInt(),
      result[6].toBigInt(),
    );
  }

  try_positions(param0: Bytes): ethereum.CallResult<Vault__positionsResult> {
    let result = super.tryCall(
      "positions",
      "positions(bytes32):(uint256,uint256,uint256,uint256,uint256,int256,uint256)",
      [ethereum.Value.fromFixedBytes(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Vault__positionsResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt(),
        value[3].toBigInt(),
        value[4].toBigInt(),
        value[5].toBigInt(),
        value[6].toBigInt(),
      ),
    );
  }

  priceFeed(): Address {
    let result = super.call("priceFeed", "priceFeed():(address)", []);

    return result[0].toAddress();
  }

  try_priceFeed(): ethereum.CallResult<Address> {
    let result = super.tryCall("priceFeed", "priceFeed():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  reservedAmounts(param0: Address): BigInt {
    let result = super.call(
      "reservedAmounts",
      "reservedAmounts(address):(uint256)",
      [ethereum.Value.fromAddress(param0)],
    );

    return result[0].toBigInt();
  }

  try_reservedAmounts(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "reservedAmounts",
      "reservedAmounts(address):(uint256)",
      [ethereum.Value.fromAddress(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  router(): Address {
    let result = super.call("router", "router():(address)", []);

    return result[0].toAddress();
  }

  try_router(): ethereum.CallResult<Address> {
    let result = super.tryCall("router", "router():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  sellUSDF(_token: Address, _receiver: Address): BigInt {
    let result = super.call("sellUSDF", "sellUSDF(address,address):(uint256)", [
      ethereum.Value.fromAddress(_token),
      ethereum.Value.fromAddress(_receiver),
    ]);

    return result[0].toBigInt();
  }

  try_sellUSDF(
    _token: Address,
    _receiver: Address,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "sellUSDF",
      "sellUSDF(address,address):(uint256)",
      [
        ethereum.Value.fromAddress(_token),
        ethereum.Value.fromAddress(_receiver),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  shortableTokens(param0: Address): boolean {
    let result = super.call(
      "shortableTokens",
      "shortableTokens(address):(bool)",
      [ethereum.Value.fromAddress(param0)],
    );

    return result[0].toBoolean();
  }

  try_shortableTokens(param0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "shortableTokens",
      "shortableTokens(address):(bool)",
      [ethereum.Value.fromAddress(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  stableTokens(param0: Address): boolean {
    let result = super.call("stableTokens", "stableTokens(address):(bool)", [
      ethereum.Value.fromAddress(param0),
    ]);

    return result[0].toBoolean();
  }

  try_stableTokens(param0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("stableTokens", "stableTokens(address):(bool)", [
      ethereum.Value.fromAddress(param0),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  swap(_tokenIn: Address, _tokenOut: Address, _receiver: Address): BigInt {
    let result = super.call("swap", "swap(address,address,address):(uint256)", [
      ethereum.Value.fromAddress(_tokenIn),
      ethereum.Value.fromAddress(_tokenOut),
      ethereum.Value.fromAddress(_receiver),
    ]);

    return result[0].toBigInt();
  }

  try_swap(
    _tokenIn: Address,
    _tokenOut: Address,
    _receiver: Address,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "swap",
      "swap(address,address,address):(uint256)",
      [
        ethereum.Value.fromAddress(_tokenIn),
        ethereum.Value.fromAddress(_tokenOut),
        ethereum.Value.fromAddress(_receiver),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  tokenBalances(param0: Address): BigInt {
    let result = super.call(
      "tokenBalances",
      "tokenBalances(address):(uint256)",
      [ethereum.Value.fromAddress(param0)],
    );

    return result[0].toBigInt();
  }

  try_tokenBalances(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "tokenBalances",
      "tokenBalances(address):(uint256)",
      [ethereum.Value.fromAddress(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  tokenDecimals(param0: Address): BigInt {
    let result = super.call(
      "tokenDecimals",
      "tokenDecimals(address):(uint256)",
      [ethereum.Value.fromAddress(param0)],
    );

    return result[0].toBigInt();
  }

  try_tokenDecimals(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "tokenDecimals",
      "tokenDecimals(address):(uint256)",
      [ethereum.Value.fromAddress(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  tokenToUsdMin(_token: Address, _tokenAmount: BigInt): BigInt {
    let result = super.call(
      "tokenToUsdMin",
      "tokenToUsdMin(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(_token),
        ethereum.Value.fromUnsignedBigInt(_tokenAmount),
      ],
    );

    return result[0].toBigInt();
  }

  try_tokenToUsdMin(
    _token: Address,
    _tokenAmount: BigInt,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "tokenToUsdMin",
      "tokenToUsdMin(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(_token),
        ethereum.Value.fromUnsignedBigInt(_tokenAmount),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  tokenWeights(param0: Address): BigInt {
    let result = super.call("tokenWeights", "tokenWeights(address):(uint256)", [
      ethereum.Value.fromAddress(param0),
    ]);

    return result[0].toBigInt();
  }

  try_tokenWeights(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "tokenWeights",
      "tokenWeights(address):(uint256)",
      [ethereum.Value.fromAddress(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  totalTokenWeights(): BigInt {
    let result = super.call(
      "totalTokenWeights",
      "totalTokenWeights():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_totalTokenWeights(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "totalTokenWeights",
      "totalTokenWeights():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  usdToToken(_token: Address, _usdAmount: BigInt, _price: BigInt): BigInt {
    let result = super.call(
      "usdToToken",
      "usdToToken(address,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(_token),
        ethereum.Value.fromUnsignedBigInt(_usdAmount),
        ethereum.Value.fromUnsignedBigInt(_price),
      ],
    );

    return result[0].toBigInt();
  }

  try_usdToToken(
    _token: Address,
    _usdAmount: BigInt,
    _price: BigInt,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "usdToToken",
      "usdToToken(address,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(_token),
        ethereum.Value.fromUnsignedBigInt(_usdAmount),
        ethereum.Value.fromUnsignedBigInt(_price),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  usdToTokenMax(_token: Address, _usdAmount: BigInt): BigInt {
    let result = super.call(
      "usdToTokenMax",
      "usdToTokenMax(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(_token),
        ethereum.Value.fromUnsignedBigInt(_usdAmount),
      ],
    );

    return result[0].toBigInt();
  }

  try_usdToTokenMax(
    _token: Address,
    _usdAmount: BigInt,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "usdToTokenMax",
      "usdToTokenMax(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(_token),
        ethereum.Value.fromUnsignedBigInt(_usdAmount),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  usdToTokenMin(_token: Address, _usdAmount: BigInt): BigInt {
    let result = super.call(
      "usdToTokenMin",
      "usdToTokenMin(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(_token),
        ethereum.Value.fromUnsignedBigInt(_usdAmount),
      ],
    );

    return result[0].toBigInt();
  }

  try_usdToTokenMin(
    _token: Address,
    _usdAmount: BigInt,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "usdToTokenMin",
      "usdToTokenMin(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(_token),
        ethereum.Value.fromUnsignedBigInt(_usdAmount),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  usdf(): Address {
    let result = super.call("usdf", "usdf():(address)", []);

    return result[0].toAddress();
  }

  try_usdf(): ethereum.CallResult<Address> {
    let result = super.tryCall("usdf", "usdf():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  usdfAmounts(param0: Address): BigInt {
    let result = super.call("usdfAmounts", "usdfAmounts(address):(uint256)", [
      ethereum.Value.fromAddress(param0),
    ]);

    return result[0].toBigInt();
  }

  try_usdfAmounts(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "usdfAmounts",
      "usdfAmounts(address):(uint256)",
      [ethereum.Value.fromAddress(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  useSwapPricing(): boolean {
    let result = super.call("useSwapPricing", "useSwapPricing():(bool)", []);

    return result[0].toBoolean();
  }

  try_useSwapPricing(): ethereum.CallResult<boolean> {
    let result = super.tryCall("useSwapPricing", "useSwapPricing():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  validateLiquidation(
    _account: Address,
    _collateralToken: Address,
    _indexToken: Address,
    _isLong: boolean,
    _raise: boolean,
  ): Vault__validateLiquidationResult {
    let result = super.call(
      "validateLiquidation",
      "validateLiquidation(address,address,address,bool,bool):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(_account),
        ethereum.Value.fromAddress(_collateralToken),
        ethereum.Value.fromAddress(_indexToken),
        ethereum.Value.fromBoolean(_isLong),
        ethereum.Value.fromBoolean(_raise),
      ],
    );

    return new Vault__validateLiquidationResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
    );
  }

  try_validateLiquidation(
    _account: Address,
    _collateralToken: Address,
    _indexToken: Address,
    _isLong: boolean,
    _raise: boolean,
  ): ethereum.CallResult<Vault__validateLiquidationResult> {
    let result = super.tryCall(
      "validateLiquidation",
      "validateLiquidation(address,address,address,bool,bool):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(_account),
        ethereum.Value.fromAddress(_collateralToken),
        ethereum.Value.fromAddress(_indexToken),
        ethereum.Value.fromBoolean(_isLong),
        ethereum.Value.fromBoolean(_raise),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Vault__validateLiquidationResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
      ),
    );
  }

  vaultUtils(): Address {
    let result = super.call("vaultUtils", "vaultUtils():(address)", []);

    return result[0].toAddress();
  }

  try_vaultUtils(): ethereum.CallResult<Address> {
    let result = super.tryCall("vaultUtils", "vaultUtils():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  whitelistedTokenCount(): BigInt {
    let result = super.call(
      "whitelistedTokenCount",
      "whitelistedTokenCount():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_whitelistedTokenCount(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "whitelistedTokenCount",
      "whitelistedTokenCount():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  whitelistedTokens(param0: Address): boolean {
    let result = super.call(
      "whitelistedTokens",
      "whitelistedTokens(address):(bool)",
      [ethereum.Value.fromAddress(param0)],
    );

    return result[0].toBoolean();
  }

  try_whitelistedTokens(param0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "whitelistedTokens",
      "whitelistedTokens(address):(bool)",
      [ethereum.Value.fromAddress(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  withdrawFees(_token: Address, _receiver: Address): BigInt {
    let result = super.call(
      "withdrawFees",
      "withdrawFees(address,address):(uint256)",
      [
        ethereum.Value.fromAddress(_token),
        ethereum.Value.fromAddress(_receiver),
      ],
    );

    return result[0].toBigInt();
  }

  try_withdrawFees(
    _token: Address,
    _receiver: Address,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "withdrawFees",
      "withdrawFees(address,address):(uint256)",
      [
        ethereum.Value.fromAddress(_token),
        ethereum.Value.fromAddress(_receiver),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class AddRouterCall extends ethereum.Call {
  get inputs(): AddRouterCall__Inputs {
    return new AddRouterCall__Inputs(this);
  }

  get outputs(): AddRouterCall__Outputs {
    return new AddRouterCall__Outputs(this);
  }
}

export class AddRouterCall__Inputs {
  _call: AddRouterCall;

  constructor(call: AddRouterCall) {
    this._call = call;
  }

  get _router(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class AddRouterCall__Outputs {
  _call: AddRouterCall;

  constructor(call: AddRouterCall) {
    this._call = call;
  }
}

export class BuyUSDFCall extends ethereum.Call {
  get inputs(): BuyUSDFCall__Inputs {
    return new BuyUSDFCall__Inputs(this);
  }

  get outputs(): BuyUSDFCall__Outputs {
    return new BuyUSDFCall__Outputs(this);
  }
}

export class BuyUSDFCall__Inputs {
  _call: BuyUSDFCall;

  constructor(call: BuyUSDFCall) {
    this._call = call;
  }

  get _token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _receiver(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class BuyUSDFCall__Outputs {
  _call: BuyUSDFCall;

  constructor(call: BuyUSDFCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class ClearTokenConfigCall extends ethereum.Call {
  get inputs(): ClearTokenConfigCall__Inputs {
    return new ClearTokenConfigCall__Inputs(this);
  }

  get outputs(): ClearTokenConfigCall__Outputs {
    return new ClearTokenConfigCall__Outputs(this);
  }
}

export class ClearTokenConfigCall__Inputs {
  _call: ClearTokenConfigCall;

  constructor(call: ClearTokenConfigCall) {
    this._call = call;
  }

  get _token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class ClearTokenConfigCall__Outputs {
  _call: ClearTokenConfigCall;

  constructor(call: ClearTokenConfigCall) {
    this._call = call;
  }
}

export class DecreasePositionCall extends ethereum.Call {
  get inputs(): DecreasePositionCall__Inputs {
    return new DecreasePositionCall__Inputs(this);
  }

  get outputs(): DecreasePositionCall__Outputs {
    return new DecreasePositionCall__Outputs(this);
  }
}

export class DecreasePositionCall__Inputs {
  _call: DecreasePositionCall;

  constructor(call: DecreasePositionCall) {
    this._call = call;
  }

  get _account(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _collateralToken(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _indexToken(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _collateralDelta(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get _sizeDelta(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }

  get _isLong(): boolean {
    return this._call.inputValues[5].value.toBoolean();
  }

  get _receiver(): Address {
    return this._call.inputValues[6].value.toAddress();
  }
}

export class DecreasePositionCall__Outputs {
  _call: DecreasePositionCall;

  constructor(call: DecreasePositionCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class DirectPoolDepositCall extends ethereum.Call {
  get inputs(): DirectPoolDepositCall__Inputs {
    return new DirectPoolDepositCall__Inputs(this);
  }

  get outputs(): DirectPoolDepositCall__Outputs {
    return new DirectPoolDepositCall__Outputs(this);
  }
}

export class DirectPoolDepositCall__Inputs {
  _call: DirectPoolDepositCall;

  constructor(call: DirectPoolDepositCall) {
    this._call = call;
  }

  get _token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class DirectPoolDepositCall__Outputs {
  _call: DirectPoolDepositCall;

  constructor(call: DirectPoolDepositCall) {
    this._call = call;
  }
}

export class IncreasePositionCall extends ethereum.Call {
  get inputs(): IncreasePositionCall__Inputs {
    return new IncreasePositionCall__Inputs(this);
  }

  get outputs(): IncreasePositionCall__Outputs {
    return new IncreasePositionCall__Outputs(this);
  }
}

export class IncreasePositionCall__Inputs {
  _call: IncreasePositionCall;

  constructor(call: IncreasePositionCall) {
    this._call = call;
  }

  get _account(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _collateralToken(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _indexToken(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _sizeDelta(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get _isLong(): boolean {
    return this._call.inputValues[4].value.toBoolean();
  }
}

export class IncreasePositionCall__Outputs {
  _call: IncreasePositionCall;

  constructor(call: IncreasePositionCall) {
    this._call = call;
  }
}

export class InitializeCall extends ethereum.Call {
  get inputs(): InitializeCall__Inputs {
    return new InitializeCall__Inputs(this);
  }

  get outputs(): InitializeCall__Outputs {
    return new InitializeCall__Outputs(this);
  }
}

export class InitializeCall__Inputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }

  get _router(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _usdf(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _priceFeed(): Address {
    return this._call.inputValues[2].value.toAddress();
  }
}

export class InitializeCall__Outputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }
}

export class LiquidatePositionCall extends ethereum.Call {
  get inputs(): LiquidatePositionCall__Inputs {
    return new LiquidatePositionCall__Inputs(this);
  }

  get outputs(): LiquidatePositionCall__Outputs {
    return new LiquidatePositionCall__Outputs(this);
  }
}

export class LiquidatePositionCall__Inputs {
  _call: LiquidatePositionCall;

  constructor(call: LiquidatePositionCall) {
    this._call = call;
  }

  get _account(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _collateralToken(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _indexToken(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _isLong(): boolean {
    return this._call.inputValues[3].value.toBoolean();
  }

  get _feeReceiver(): Address {
    return this._call.inputValues[4].value.toAddress();
  }
}

export class LiquidatePositionCall__Outputs {
  _call: LiquidatePositionCall;

  constructor(call: LiquidatePositionCall) {
    this._call = call;
  }
}

export class RemoveRouterCall extends ethereum.Call {
  get inputs(): RemoveRouterCall__Inputs {
    return new RemoveRouterCall__Inputs(this);
  }

  get outputs(): RemoveRouterCall__Outputs {
    return new RemoveRouterCall__Outputs(this);
  }
}

export class RemoveRouterCall__Inputs {
  _call: RemoveRouterCall;

  constructor(call: RemoveRouterCall) {
    this._call = call;
  }

  get _router(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class RemoveRouterCall__Outputs {
  _call: RemoveRouterCall;

  constructor(call: RemoveRouterCall) {
    this._call = call;
  }
}

export class SellUSDFCall extends ethereum.Call {
  get inputs(): SellUSDFCall__Inputs {
    return new SellUSDFCall__Inputs(this);
  }

  get outputs(): SellUSDFCall__Outputs {
    return new SellUSDFCall__Outputs(this);
  }
}

export class SellUSDFCall__Inputs {
  _call: SellUSDFCall;

  constructor(call: SellUSDFCall) {
    this._call = call;
  }

  get _token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _receiver(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class SellUSDFCall__Outputs {
  _call: SellUSDFCall;

  constructor(call: SellUSDFCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class SetBufferAmountCall extends ethereum.Call {
  get inputs(): SetBufferAmountCall__Inputs {
    return new SetBufferAmountCall__Inputs(this);
  }

  get outputs(): SetBufferAmountCall__Outputs {
    return new SetBufferAmountCall__Outputs(this);
  }
}

export class SetBufferAmountCall__Inputs {
  _call: SetBufferAmountCall;

  constructor(call: SetBufferAmountCall) {
    this._call = call;
  }

  get _token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class SetBufferAmountCall__Outputs {
  _call: SetBufferAmountCall;

  constructor(call: SetBufferAmountCall) {
    this._call = call;
  }
}

export class SetErrorCall extends ethereum.Call {
  get inputs(): SetErrorCall__Inputs {
    return new SetErrorCall__Inputs(this);
  }

  get outputs(): SetErrorCall__Outputs {
    return new SetErrorCall__Outputs(this);
  }
}

export class SetErrorCall__Inputs {
  _call: SetErrorCall;

  constructor(call: SetErrorCall) {
    this._call = call;
  }

  get _errorCode(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _error(): string {
    return this._call.inputValues[1].value.toString();
  }
}

export class SetErrorCall__Outputs {
  _call: SetErrorCall;

  constructor(call: SetErrorCall) {
    this._call = call;
  }
}

export class SetErrorControllerCall extends ethereum.Call {
  get inputs(): SetErrorControllerCall__Inputs {
    return new SetErrorControllerCall__Inputs(this);
  }

  get outputs(): SetErrorControllerCall__Outputs {
    return new SetErrorControllerCall__Outputs(this);
  }
}

export class SetErrorControllerCall__Inputs {
  _call: SetErrorControllerCall;

  constructor(call: SetErrorControllerCall) {
    this._call = call;
  }

  get _errorController(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetErrorControllerCall__Outputs {
  _call: SetErrorControllerCall;

  constructor(call: SetErrorControllerCall) {
    this._call = call;
  }
}

export class SetFeeUtilsCall extends ethereum.Call {
  get inputs(): SetFeeUtilsCall__Inputs {
    return new SetFeeUtilsCall__Inputs(this);
  }

  get outputs(): SetFeeUtilsCall__Outputs {
    return new SetFeeUtilsCall__Outputs(this);
  }
}

export class SetFeeUtilsCall__Inputs {
  _call: SetFeeUtilsCall;

  constructor(call: SetFeeUtilsCall) {
    this._call = call;
  }

  get _feeUtils(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetFeeUtilsCall__Outputs {
  _call: SetFeeUtilsCall;

  constructor(call: SetFeeUtilsCall) {
    this._call = call;
  }
}

export class SetGovCall extends ethereum.Call {
  get inputs(): SetGovCall__Inputs {
    return new SetGovCall__Inputs(this);
  }

  get outputs(): SetGovCall__Outputs {
    return new SetGovCall__Outputs(this);
  }
}

export class SetGovCall__Inputs {
  _call: SetGovCall;

  constructor(call: SetGovCall) {
    this._call = call;
  }

  get _gov(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetGovCall__Outputs {
  _call: SetGovCall;

  constructor(call: SetGovCall) {
    this._call = call;
  }
}

export class SetInManagerModeCall extends ethereum.Call {
  get inputs(): SetInManagerModeCall__Inputs {
    return new SetInManagerModeCall__Inputs(this);
  }

  get outputs(): SetInManagerModeCall__Outputs {
    return new SetInManagerModeCall__Outputs(this);
  }
}

export class SetInManagerModeCall__Inputs {
  _call: SetInManagerModeCall;

  constructor(call: SetInManagerModeCall) {
    this._call = call;
  }

  get _inManagerMode(): boolean {
    return this._call.inputValues[0].value.toBoolean();
  }
}

export class SetInManagerModeCall__Outputs {
  _call: SetInManagerModeCall;

  constructor(call: SetInManagerModeCall) {
    this._call = call;
  }
}

export class SetInPrivateLiquidationModeCall extends ethereum.Call {
  get inputs(): SetInPrivateLiquidationModeCall__Inputs {
    return new SetInPrivateLiquidationModeCall__Inputs(this);
  }

  get outputs(): SetInPrivateLiquidationModeCall__Outputs {
    return new SetInPrivateLiquidationModeCall__Outputs(this);
  }
}

export class SetInPrivateLiquidationModeCall__Inputs {
  _call: SetInPrivateLiquidationModeCall;

  constructor(call: SetInPrivateLiquidationModeCall) {
    this._call = call;
  }

  get _inPrivateLiquidationMode(): boolean {
    return this._call.inputValues[0].value.toBoolean();
  }
}

export class SetInPrivateLiquidationModeCall__Outputs {
  _call: SetInPrivateLiquidationModeCall;

  constructor(call: SetInPrivateLiquidationModeCall) {
    this._call = call;
  }
}

export class SetIsLeverageEnabledCall extends ethereum.Call {
  get inputs(): SetIsLeverageEnabledCall__Inputs {
    return new SetIsLeverageEnabledCall__Inputs(this);
  }

  get outputs(): SetIsLeverageEnabledCall__Outputs {
    return new SetIsLeverageEnabledCall__Outputs(this);
  }
}

export class SetIsLeverageEnabledCall__Inputs {
  _call: SetIsLeverageEnabledCall;

  constructor(call: SetIsLeverageEnabledCall) {
    this._call = call;
  }

  get _isLeverageEnabled(): boolean {
    return this._call.inputValues[0].value.toBoolean();
  }
}

export class SetIsLeverageEnabledCall__Outputs {
  _call: SetIsLeverageEnabledCall;

  constructor(call: SetIsLeverageEnabledCall) {
    this._call = call;
  }
}

export class SetIsSwapEnabledCall extends ethereum.Call {
  get inputs(): SetIsSwapEnabledCall__Inputs {
    return new SetIsSwapEnabledCall__Inputs(this);
  }

  get outputs(): SetIsSwapEnabledCall__Outputs {
    return new SetIsSwapEnabledCall__Outputs(this);
  }
}

export class SetIsSwapEnabledCall__Inputs {
  _call: SetIsSwapEnabledCall;

  constructor(call: SetIsSwapEnabledCall) {
    this._call = call;
  }

  get _isSwapEnabled(): boolean {
    return this._call.inputValues[0].value.toBoolean();
  }
}

export class SetIsSwapEnabledCall__Outputs {
  _call: SetIsSwapEnabledCall;

  constructor(call: SetIsSwapEnabledCall) {
    this._call = call;
  }
}

export class SetLiquidatorCall extends ethereum.Call {
  get inputs(): SetLiquidatorCall__Inputs {
    return new SetLiquidatorCall__Inputs(this);
  }

  get outputs(): SetLiquidatorCall__Outputs {
    return new SetLiquidatorCall__Outputs(this);
  }
}

export class SetLiquidatorCall__Inputs {
  _call: SetLiquidatorCall;

  constructor(call: SetLiquidatorCall) {
    this._call = call;
  }

  get _liquidator(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _isActive(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class SetLiquidatorCall__Outputs {
  _call: SetLiquidatorCall;

  constructor(call: SetLiquidatorCall) {
    this._call = call;
  }
}

export class SetManagerCall extends ethereum.Call {
  get inputs(): SetManagerCall__Inputs {
    return new SetManagerCall__Inputs(this);
  }

  get outputs(): SetManagerCall__Outputs {
    return new SetManagerCall__Outputs(this);
  }
}

export class SetManagerCall__Inputs {
  _call: SetManagerCall;

  constructor(call: SetManagerCall) {
    this._call = call;
  }

  get _manager(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _isManager(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class SetManagerCall__Outputs {
  _call: SetManagerCall;

  constructor(call: SetManagerCall) {
    this._call = call;
  }
}

export class SetMaxGasPriceCall extends ethereum.Call {
  get inputs(): SetMaxGasPriceCall__Inputs {
    return new SetMaxGasPriceCall__Inputs(this);
  }

  get outputs(): SetMaxGasPriceCall__Outputs {
    return new SetMaxGasPriceCall__Outputs(this);
  }
}

export class SetMaxGasPriceCall__Inputs {
  _call: SetMaxGasPriceCall;

  constructor(call: SetMaxGasPriceCall) {
    this._call = call;
  }

  get _maxGasPrice(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class SetMaxGasPriceCall__Outputs {
  _call: SetMaxGasPriceCall;

  constructor(call: SetMaxGasPriceCall) {
    this._call = call;
  }
}

export class SetMaxGlobalShortSizeCall extends ethereum.Call {
  get inputs(): SetMaxGlobalShortSizeCall__Inputs {
    return new SetMaxGlobalShortSizeCall__Inputs(this);
  }

  get outputs(): SetMaxGlobalShortSizeCall__Outputs {
    return new SetMaxGlobalShortSizeCall__Outputs(this);
  }
}

export class SetMaxGlobalShortSizeCall__Inputs {
  _call: SetMaxGlobalShortSizeCall;

  constructor(call: SetMaxGlobalShortSizeCall) {
    this._call = call;
  }

  get _token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class SetMaxGlobalShortSizeCall__Outputs {
  _call: SetMaxGlobalShortSizeCall;

  constructor(call: SetMaxGlobalShortSizeCall) {
    this._call = call;
  }
}

export class SetMaxLeverageCall extends ethereum.Call {
  get inputs(): SetMaxLeverageCall__Inputs {
    return new SetMaxLeverageCall__Inputs(this);
  }

  get outputs(): SetMaxLeverageCall__Outputs {
    return new SetMaxLeverageCall__Outputs(this);
  }
}

export class SetMaxLeverageCall__Inputs {
  _call: SetMaxLeverageCall;

  constructor(call: SetMaxLeverageCall) {
    this._call = call;
  }

  get _maxLeverage(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class SetMaxLeverageCall__Outputs {
  _call: SetMaxLeverageCall;

  constructor(call: SetMaxLeverageCall) {
    this._call = call;
  }
}

export class SetMinProfitTimeCall extends ethereum.Call {
  get inputs(): SetMinProfitTimeCall__Inputs {
    return new SetMinProfitTimeCall__Inputs(this);
  }

  get outputs(): SetMinProfitTimeCall__Outputs {
    return new SetMinProfitTimeCall__Outputs(this);
  }
}

export class SetMinProfitTimeCall__Inputs {
  _call: SetMinProfitTimeCall;

  constructor(call: SetMinProfitTimeCall) {
    this._call = call;
  }

  get _minProfitTime(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class SetMinProfitTimeCall__Outputs {
  _call: SetMinProfitTimeCall;

  constructor(call: SetMinProfitTimeCall) {
    this._call = call;
  }
}

export class SetPriceFeedCall extends ethereum.Call {
  get inputs(): SetPriceFeedCall__Inputs {
    return new SetPriceFeedCall__Inputs(this);
  }

  get outputs(): SetPriceFeedCall__Outputs {
    return new SetPriceFeedCall__Outputs(this);
  }
}

export class SetPriceFeedCall__Inputs {
  _call: SetPriceFeedCall;

  constructor(call: SetPriceFeedCall) {
    this._call = call;
  }

  get _priceFeed(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetPriceFeedCall__Outputs {
  _call: SetPriceFeedCall;

  constructor(call: SetPriceFeedCall) {
    this._call = call;
  }
}

export class SetTokenConfigCall extends ethereum.Call {
  get inputs(): SetTokenConfigCall__Inputs {
    return new SetTokenConfigCall__Inputs(this);
  }

  get outputs(): SetTokenConfigCall__Outputs {
    return new SetTokenConfigCall__Outputs(this);
  }
}

export class SetTokenConfigCall__Inputs {
  _call: SetTokenConfigCall;

  constructor(call: SetTokenConfigCall) {
    this._call = call;
  }

  get _token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _tokenDecimals(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get _tokenWeight(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get _minProfitBps(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get _maxUsdfAmount(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }

  get _isStable(): boolean {
    return this._call.inputValues[5].value.toBoolean();
  }

  get _isShortable(): boolean {
    return this._call.inputValues[6].value.toBoolean();
  }
}

export class SetTokenConfigCall__Outputs {
  _call: SetTokenConfigCall;

  constructor(call: SetTokenConfigCall) {
    this._call = call;
  }
}

export class SetUsdfAmountCall extends ethereum.Call {
  get inputs(): SetUsdfAmountCall__Inputs {
    return new SetUsdfAmountCall__Inputs(this);
  }

  get outputs(): SetUsdfAmountCall__Outputs {
    return new SetUsdfAmountCall__Outputs(this);
  }
}

export class SetUsdfAmountCall__Inputs {
  _call: SetUsdfAmountCall;

  constructor(call: SetUsdfAmountCall) {
    this._call = call;
  }

  get _token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class SetUsdfAmountCall__Outputs {
  _call: SetUsdfAmountCall;

  constructor(call: SetUsdfAmountCall) {
    this._call = call;
  }
}

export class SetVaultUtilsCall extends ethereum.Call {
  get inputs(): SetVaultUtilsCall__Inputs {
    return new SetVaultUtilsCall__Inputs(this);
  }

  get outputs(): SetVaultUtilsCall__Outputs {
    return new SetVaultUtilsCall__Outputs(this);
  }
}

export class SetVaultUtilsCall__Inputs {
  _call: SetVaultUtilsCall;

  constructor(call: SetVaultUtilsCall) {
    this._call = call;
  }

  get _vaultUtils(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetVaultUtilsCall__Outputs {
  _call: SetVaultUtilsCall;

  constructor(call: SetVaultUtilsCall) {
    this._call = call;
  }
}

export class SwapCall extends ethereum.Call {
  get inputs(): SwapCall__Inputs {
    return new SwapCall__Inputs(this);
  }

  get outputs(): SwapCall__Outputs {
    return new SwapCall__Outputs(this);
  }
}

export class SwapCall__Inputs {
  _call: SwapCall;

  constructor(call: SwapCall) {
    this._call = call;
  }

  get _tokenIn(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _tokenOut(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _receiver(): Address {
    return this._call.inputValues[2].value.toAddress();
  }
}

export class SwapCall__Outputs {
  _call: SwapCall;

  constructor(call: SwapCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class UpgradeVaultCall extends ethereum.Call {
  get inputs(): UpgradeVaultCall__Inputs {
    return new UpgradeVaultCall__Inputs(this);
  }

  get outputs(): UpgradeVaultCall__Outputs {
    return new UpgradeVaultCall__Outputs(this);
  }
}

export class UpgradeVaultCall__Inputs {
  _call: UpgradeVaultCall;

  constructor(call: UpgradeVaultCall) {
    this._call = call;
  }

  get _newVault(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _token(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class UpgradeVaultCall__Outputs {
  _call: UpgradeVaultCall;

  constructor(call: UpgradeVaultCall) {
    this._call = call;
  }
}

export class WithdrawFeesCall extends ethereum.Call {
  get inputs(): WithdrawFeesCall__Inputs {
    return new WithdrawFeesCall__Inputs(this);
  }

  get outputs(): WithdrawFeesCall__Outputs {
    return new WithdrawFeesCall__Outputs(this);
  }
}

export class WithdrawFeesCall__Inputs {
  _call: WithdrawFeesCall;

  constructor(call: WithdrawFeesCall) {
    this._call = call;
  }

  get _token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _receiver(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class WithdrawFeesCall__Outputs {
  _call: WithdrawFeesCall;

  constructor(call: WithdrawFeesCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}
